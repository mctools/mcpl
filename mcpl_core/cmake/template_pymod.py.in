
# This is the _mcpl_core.info Python module, containing appropriate wrapper
# functions for exposing mcpl-config and mcpltool as Python entry-points, and
# containing information about the installation. Several of the strings in this
# file has content generated by CMake.

#Expanded by CMake:
_has_shlib_in_scripts_dir = bool('@mcpl_pymod_shlib_in_scripts@')

def _mcpl_config_cli_wrapper():
    import subprocess
    import pathlib
    import sys
    f = pathlib.Path(__file__).parent.joinpath('data','bin','mcpl-config')
    a = sys.argv[:]
    a[0] = f
    if _has_shlib_in_scripts_dir:
        #Windows, must let the binary mcpl-config know about the actual
        #shlibpath:
        lp = libpath().parent
        a.append('+')
        a.append(str(lp))
    rv = subprocess.run( a )
    raise SystemExit(rv.returncode)

def _mcpl_tool_cli_wrapper():
    import subprocess
    import pathlib
    import sys
    f = pathlib.Path(__file__).parent.joinpath('data','bin','mcpltool')
    a = sys.argv[:]
    a[0] = f
    rv = subprocess.run( a )
    raise SystemExit(rv.returncode)

def version():
    #Expanded by CMake:
    return '@MCPL_VERSION@'

def libname():
    #Expanded by CMake:
    return '$<TARGET_FILE_NAME:mcpl>'#NB: generator expression

#def namespace():
#    #Expanded by CMake:
#    #FIXME: support namespace
#    return '@MCPL_NAMESPACE@'

_cache_libpath = [None]
def libpath():
    if _cache_libpath[0] is None:
        _cache_libpath[0] = _libpath_impl()
    return _cache_libpath[0]

def _libpath_impl():
    import pathlib
    shlib_name = libname()
    if not _has_shlib_in_scripts_dir:
        #Not windows, we have the shared library (.so or .dylib) in the module
        #data dir:
        shlib_dirname = '@mcpl_pymod_shlib_dirname@' #Expanded by CMake
        return pathlib.Path(__file__).parent.joinpath(
            'data', shlib_dirname, shlib_name
        ).absolute().resolve()

    #Windows. The DLL is in the scripts directory (to be in %PATH%). To be safe
    #we look not only in the default scheme, but also in a few other preferred
    #schemes:
    import sysconfig
    schemes = []

    if hasattr(sysconfig,'get_default_scheme'):
        #py 3.10+
        schemes += [ sysconfig.get_default_scheme() ]
    else:
        #py 3.9 or earlier
        schemes += [ sysconfig._get_default_scheme() ]

    if hasattr(sysconfig,'get_preferred_scheme'):
        #py 3.10+
        for scheme_key in ['prefix','home','user']:
            scheme = sysconfig.get_preferred_scheme(scheme_key)
            if scheme not in schemes:
                schemes.append(scheme)
    else:
        #Tack on everything in py 3.9 or earlier:
        schemes += list( sysconfig.get_scheme_names() )

    for scheme in schemes:
        p = pathlib.Path( sysconfig.get_path('scripts',scheme) )
        p = p.joinpath(shlib_name)
        if p.is_file():
            return p.absolute().resolve()

    #Error:
    ln = libname()
    raise RuntimeError('Unable to locate shared library (expected '
                       f'{ln} in Python site scripts directory)')
